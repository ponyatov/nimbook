# `Object` базовый класс узла объектного графа

структура базового объекта (узла) выбиралась исходя из **универсального представления знаний** которое должно обеспечить
* унифицированное представление одновременно и *любых* данных, и методов их обработки (программы, алгоритмы), 
* средства анализа и транформации (поиск, выборка по шаблону, правила преобразования)
* простую реализацию синтаксических анализаторов и кодогенераторов
  * для разработки ПО и 
  * разгребания legacy кода (на любых языках программирования и управления проектами), а также
  * чтения/записи текстовых ASCII форматов данных (САПР, форматы обмена, JSON/XML/...)

за основу была взята
* фреймовая модель
  * Marvin Minsky [A Framework for Representing Knowledge](https://web.media.mit.edu/~minsky/papers/Frames/frames.html)
  * Марвин Минский [*Фреймы* для представления знаний](https://www.litmir.me/br/?b=134682)
* KR&R: Knowledge representation and reasoning
  * [Представление знаний и методы логического вывода](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B7%D0%BD%D0%B0%D0%BD%D0%B8%D0%B9)
  * https://en.wikipedia.org/wiki/Knowledge_representation_and_reasoning

```py
class Object:
    def __init__(self, V):
        # скалярное значение: имя объекта, строка/число,..
        self.val = V
        # слоты = атрибуты = ассоциативный массив = словарь (key/value)
        self.slot = {}
        # вложенные элементы = упорядоченный контейнер = вектор = список = очередь
        self.nest = []
        # уникальный id для хранения в БД или key/value хранилищах
        self.id = '%x' % id(self)
```


Остальные типы узлов наследуются непосредственно от `Object` или от абстрактных классов, группирующих типы и общее поведение для каждой группы. Наследование совершенно произвольное, в зависимости от конкретной решаемой задачи: какие-то понятия прикладной области, форматы данных, онтология, семантические сети и т.д.

## [[metaL core]]
